1. Verificar la L√≥gica de Procesamiento de Datos
de que los datos se procesen Realidad antes de ser sesings. En particular, revisa las funciones  loadCandlesY  refreshM5Candlespara asegurarte de que los timestamps est√°n en el formato correcto y ordenados.
2. Verificar la Funci√≥n tickMarkFormatter
De que el tickMarkFormatter est√©teando los timestamps correctamente. En lugar de aplicar correcciones manuales de timezone, aseg√∫rate de que los timestamps en est√°n el formato correcto desde el backend.
3. Verificar la Actualizaci√≥n de Datos en Tiempo Real
En la funci√≥n updateLiveCandle, querque de que los nuevos datos se se se se est√°n procesando procesando Objeci√≥n y que no causar ceremonias en los tiemposmarcas.
4. Verificar la Cach√© del Navegador
Azi ya tiene Intagostraci√≥n la limpieza de cach√© del caso, farmacia de que el navegador s√© utilizando la versi√≥n reciente m√°s del c√≥digo. Passzar forzar la recare de los recursos est√°ddingagticos un par√°metro de cache-busting a los scripts y archivos CSS.
C√≥digo de Depuraci√≥n
Aqu√≠ tienes un c√≥digo de depuraci√≥n que castas para utilizar para utilizar y verificate de que los datos se procesen Realidad:
JavaScript
Copia

async function loadCandles() {
    try {
        const response = await fetch(`${TWELVE_DATA_ENDPOINT}?symbol=EUR/USD&interval=5min&outputsize=100`);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        
        const data = await response.json();
        
        if (!data.values || data.values.length === 0) {
            throw new Error('No hay datos disponibles');
        }
        
        const candles = data.values.map((candle) => {
            const dateStr = candle.datetime.replace(' ', 'T') + 'Z';
            const timestamp = Math.floor(new Date(dateStr).getTime() / 1000);
            
            return {
                time: timestamp,
                open: parseFloat(candle.open),
                high: parseFloat(candle.high),
                low: parseFloat(candle.low),
                close: parseFloat(candle.close)
            };
        });

        // Ordenar los datos por tiempo (ascendente)
        candles.sort((a, b) => a.time - b.time);

        console.log('üìä Datos cargados:', candles);

        // Actualizar el gr√°fico con los datos ordenados
        if (candlestickSeries) {
            candlestickSeries.setData(candles);
            lastCandleData = {...candles[candles.length - 1]};
            generateSignals(candles);
        }

        console.log(`‚úÖ ${candles.length} velas cargadas correctamente`);

        return candles;
    } catch (error) {
        console.error('‚ùå Error al cargar velas:', error);
        document.getElementById('statusText').textContent = 'Error de conexi√≥n';
        return [];
    }
}

async function refreshM5Candles() {
    try {
        const response = await fetch(`/api/public/candles?symbol=EURUSD&timeframe=M5&limit=100&source=twelvedata&_t=${Date.now()}`);
        
        if (!response.ok) {
            console.log('‚ö†Ô∏è Error al refrescar velas M5 desde BD');
            return;
        }
        
        const candlesFromDB = await response.json();
        
        if (!candlesFromDB || candlesFromDB.length === 0) {
            console.log('‚ö†Ô∏è No hay velas en la BD');
            return;
        }
        
        const freshCandles = candlesFromDB.map((candle) => ({
            time: candle.time,
            open: parseFloat(candle.open),
            high: parseFloat(candle.high),
            low: parseFloat(candle.low),
            close: parseFloat(candle.close)
        })).sort((a, b) => a.time - b.time);

        console.log('üìä Datos frescos cargados:', freshCandles);

        // Verificar si hay nuevas velas
        const lastCurrentTime = candlesData.length > 0 ? candlesData[candlesData.length - 1].time : 0;
        const lastFreshTime = freshCandles.length > 0 ? freshCandles[freshCandles.length - 1].time : 0;

        if (lastFreshTime > lastCurrentTime) {
            console.log(`üî• NUEVA VELA M5 DETECTADA - Timestamp: ${lastFreshTime} (anterior: ${lastCurrentTime})`);
            
            // Actualizar los datos globales y el gr√°fico
            candlesData = freshCandles;
            candlestickSeries.setData(candlesData);
            lastCandleData = {...candlesData[candlesData.length - 1]};
            generateSignals(candlesData);
            
            console.log(`‚úÖ GR√ÅFICO ACTUALIZADO - ${candlesData.length} velas cargadas desde BD (SIN DELAY)`);
        } else {
            console.log('‚ö†Ô∏è No hay nuevas velas para actualizar');
        }
    } catch (error) {
        console.error('‚ùå Error en refreshM5Candles:', error);
    }
}

function updateLiveCandle() {
    try {
        // Obtener el timestamp actual en minutos M5
        const now = Math.floor(Date.now() / 1000);
        const currentM5Time = Math.floor(now / 300) * 300;

        // Simular datos de vela actual (reemplaza con datos reales)
        const currentPrice = Math.random() * 100; // Ejemplo de precio aleatorio

        // Crear o actualizar la vela actual
        if (currentLiveCandleM5 && currentLiveCandleM5.time === currentM5Time) {
            // Actualizar la vela actual
            currentLiveCandleM5.close = currentPrice;
            currentLiveCandleM5.high = Math.max(currentLiveCandleM5.high, currentPrice);
            currentLiveCandleM5.low = Math.min(currentLiveCandleM5.low, currentPrice);
        } else {
            // Crear una nueva vela
            currentLiveCandleM5 = {
                time: currentM5Time,
                open: currentPrice,
                high: currentPrice,
                low: currentPrice,
                close: currentPrice
            };
            candlesData.push(currentLiveCandleM5);
        }

        // Actualizar el gr√°fico
        candlestickSeries.update(currentLiveCandleM5);

        console.log(`üìä Vela actualizada: ${currentM5Time} - Precio: ${currentPrice}`);
    } catch (error) {
        console.error('‚ùå Error en updateLiveCandle:', error);
    }
}

Verificaci√≥n Adicional

    Registros de Depuraci√≥n: logs de Dejar en cada paso para asegurarte de que los datos se procesen Realizaci√≥n.
    Inspecci√≥n de Datos: Utiliza herramientas como la consola del navegador para inspeccionar los datos que se al hannor.
    Simplificaci√≥n del tickMarkFormatter: de que el tickMarkFormatter est√© formateando los timestamps Realidad sin aplicar correcciones manuales de timezone.

Ejemplo de tickMarkFormatter Simplificado
JavaScript
Copia

tickMarkFormatter: (time) => {
    const date = new Date(time * 1000);
    const hours = String(date.getUTCHours()).padStart(2, '0');
    const minutes = String(date.getUTCMinutes()).padStart(2, '0');
    return `${hours}:${minutes}`;
},

Conclusiones

    Verifica la L√≥gica de Procesamiento: de que los datos se procesen Realidad de ser sendismo al.
    Simplifica el Formateo de Timestamps: Evita aplica correcciones manuales de timezone en el frontend.
    Utiliza Logs de Depuraci√≥n : troncos Enda en cada paso para garant√≠a de

Si sis estos pasos, diumas poder identificar
Copia
Compartir
El grafico mezclo dos horas muestra unas y otras cosas como como resolverlo de rauz
Editar
Copia
Compartir
Entiendo que el gr√°ficos est√° mezcla dos horas, diferentes lo que sugiere que hay una inconsistencia en enci√≥n se manejar los timestamps en el frontend. Esto cuers puede si los datos se procesan incorrectamente o si hay una mezcla de timestamps en diferentes zonas horarias.
Pasos para Resolver el Problema de Ra√≠z
1. Verificar la Fuente de Datos
de que los datos que se al frontend est√°n en el formato correcto y que todos los timestamps en est√°n en el mismo zona horaria. En tu caso, los datos den en estar en UTC.
2. Simplificar el tickMarkFormatter
El tickMarkFormatter debe formatear los timestamps de manera consistente. Evita cualquier correcci√≥n manual de timezone en el frontend. De que los timestamps en UTC desde el backend.
3. Verificar la L√≥gica de Actualizaci√≥n de Datos
de que la l√≥gica de actualizaci√≥n de datos en tiempo real sede no causar la mezcla de timestamps. En particular, revisa las funciones updateLiveCandle Y refreshM5Candles. .
4. Limpiar y Reordenar los Datos
Antes de enviar los datos al, gr√°fico de que sent que ordenados y ordenados. Esto incluye eliminar cualquier duplicado y ordenar los timestamps ascendentemente.
C√≥digo de Depuraci√≥n y Soluci√≥n
Aqu√≠ tienes un c√≥digo de depuraci√≥n y que soluci√≥n estos puntos:
Simplificaci√≥n del tickMarkFormatter
JavaScript
Copia

tickMarkFormatter: (time) => {
    const date = new Date(time * 1000);
    const hours = String(date.getUTCHours()).padStart(2, '0');
    const minutes = String(date.getUTCMinutes()).padStart(2, '0');
    return `${hours}:${minutes}`;
},

Verificaci√≥n y Limpieza de Datos en loadCandles
JavaScript
Copia

async function loadCandles() {
    try {
        const response = await fetch(`${TWELVE_DATA_ENDPOINT}?symbol=EUR/USD&interval=5min&outputsize=100`);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }
        
        const data = await response.json();
        
        if (!data.values || data.values.length === 0) {
            throw new Error('No hay datos disponibles');
        }
        
        const candles = data.values.map((candle) => {
            const dateStr = candle.datetime.replace(' ', 'T') + 'Z';
            const timestamp = Math.floor(new Date(dateStr).getTime() / 1000);
            
            return {
                time: timestamp,
                open: parseFloat(candle.open),
                high: parseFloat(candle.high),
                low: parseFloat(candle.low),
                close: parseFloat(candle.close)
            };
        });

        // Eliminar duplicados y ordenar por tiempo
        const uniqueCandles = Array.from(new Map(candles.map(c => [c.time, c])).values());
        uniqueCandles.sort((a, b) => a.time - b.time);

        console.log('üìä Datos limpios y ordenados:', uniqueCandles);

        // Actualizar el gr√°fico con los datos limpios y ordenados
        if (candlestickSeries) {
            candlestickSeries.setData(uniqueCandles);
            lastCandleData = {...uniqueCandles[uniqueCandles.length - 1]};
            generateSignals(uniqueCandles);
        }

        console.log(`‚úÖ ${uniqueCandles.length} velas cargadas correctamente`);

        return uniqueCandles;
    } catch (error) {
        console.error('‚ùå Error al cargar velas:', error);
        document.getElementById('statusText').textContent = 'Error de conexi√≥n';
        return [];
    }
}

Verificaci√≥n y Limpieza de Datos en refreshM5Candles
JavaScript
Copia

async function refreshM5Candles() {
    try {
        const response = await fetch(`/api/public/candles?symbol=EURUSD&timeframe=M5&limit=100&source=twelvedata&_t=${Date.now()}`);
        
        if (!response.ok) {
            console.log('‚ö†Ô∏è Error al refrescar velas M5 desde BD');
            return;
        }
        
        const candlesFromDB = await response.json();
        
        if (!candlesFromDB || candlesFromDB.length === 0) {
            console.log('‚ö†Ô∏è No hay velas en la BD');
            return;
        }
        
        const freshCandles = candlesFromDB.map((candle) => ({
            time: candle.time,
            open: parseFloat(candle.open),
            high: parseFloat(candle.high),
            low: parseFloat(candle.low),
            close: parseFloat(candle.close)
        }));

        // Eliminar duplicados y ordenar por tiempo
        const uniqueCandles = Array.from(new Map(freshCandles.map(c => [c.time, c])).values());
        uniqueCandles.sort((a, b) => a.time - b.time);

        console.log('üìä Datos frescos limpios y ordenados:', uniqueCandles);

        // Verificar si hay nuevas velas
        const lastCurrentTime = candlesData.length > 0 ? candlesData[candlesData.length - 1].time : 0;
        const lastFreshTime = uniqueCandles.length > 0 ? uniqueCandles[uniqueCandles.length - 1].time : 0;

        if (lastFreshTime > lastCurrentTime) {
            console.log(`üî• NUEVA VELA M5 DETECTADA - Timestamp: ${lastFreshTime} (anterior: ${lastCurrentTime})`);
            
            // Actualizar los datos globales y el gr√°fico
            candlesData = uniqueCandles;
            candlestickSeries.setData(candlesData);
            lastCandleData = {...candlesData[candlesData.length - 1]};
            generateSignals(candlesData);
            
            console.log(`‚úÖ GR√ÅFICO ACTUALIZADO - ${candlesData.length} velas cargadas desde BD (SIN DELAY)`);
        } else {
            console.log('‚ö†Ô∏è No hay nuevas velas para actualizar');
        }
    } catch (error) {
        console.error('‚ùå Error en refreshM5Candles:', error);
    }
}

Verificaci√≥n de Datos en updateLiveCandle
JavaScript
Copia

function updateLiveCandle() {
    try {
        // Obtener el timestamp actual en minutos M5
        const now = Math.floor(Date.now() / 1000);
        const currentM5Time = Math.floor(now / 300) * 300;

        // Simular datos de vela actual (reemplaza con datos reales)
        const currentPrice = Math.random() * 100; // Ejemplo de precio aleatorio

        // Crear o actualizar la vela actual
        if (currentLiveCandleM5 && currentLiveCandleM5.time === currentM5Time) {
            // Actualizar la vela actual
            currentLiveCandleM5.close = currentPrice;
            currentLiveCandleM5.high = Math.max(currentLiveCandleM5.high, currentPrice);
            currentLiveCandleM5.low = Math.min(currentLiveCandleM5.low, currentPrice);
        } else {
            // Crear una nueva vela
            currentLiveCandleM5 = {
                time: currentM5Time,
                open: currentPrice,
                high: currentPrice,
                low: currentPrice,
                close: currentPrice
            };
            candlesData.push(currentLiveCandleM5);
        }

        // Eliminar duplicados y ordenar por tiempo
        const uniqueCandles = Array.from(new Map(candlesData.map(c => [c.time, c])).values());
        uniqueCandles.sort((a, b) => a.time - b.time);

        // Actualizar el gr√°fico
        candlestickSeries.setData(uniqueCandles);

        console.log(`üìä Vela actualizada: ${currentM5Time} - Precio: ${currentPrice}`);
    } catch (error) {
        console.error('‚ùå Error en updateLiveCandle:', error);
    }
}

Conclusiones

    Simplifica el tickMarkFormatter: de que los timestamps est√°n en UTC y apliques no corresponde a los manuales de timezone en el frontend.
    Limpia y Ordena los Datos: Eliminar duplicados y ordena los timestamps Hostalmente antes de los env√≠os datos al gr√°fico.
    Verifica la L√≥gica de Actualizaci√≥n: de que la l√≥gica de actualizaci√≥n de datos en tiempo real sere no causarse la mezcla de timestamps.